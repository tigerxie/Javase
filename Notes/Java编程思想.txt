Java编程思想

对象导论
Tags: Priority 1

抽象过程
Tags: Red

汇编语言

底层机器的轻微抽象

【命令式】语言

C、BASIC

对汇编的抽象

解决问题时

基于计算机的结构

不是基于所要解决的问题的结构

指针对待解决问题建模

世界的某些特定视图

LISP

所有问题最终都是列表

APL

所有问题都是算法形式的

不能解决所有问题

面向对象 OOP

表示问题空间的元素

不受限于任何特定类型的问题

每个对象都有一个接口
Tags: Orange

类

问题空间的元素<-map->解空间的对象

接口

确定了某一对象所能发出的请求

每个对象都提供服务
Tags: Blue

把对象想象成“服务提供者”

开发或理解程序

提高【内聚性】，不试图做更多的事

被隐藏的具体实现
Tags: Green

访问控制

让客户端程序员无法触及到他们不应该触及的部分

允许库设计者可以改变类内部的工作方式而不用担心会影响客户端程序员

关键字

public：任何类都可以访问

private：仅自己可以访问

protected：继承的类可以访问

default：同一个包可以访问

复用具体实现
Tags: Purple

组合

现有的类->新的类

极大的灵活性

继承

编译器->继承的类->编译时的限制

继承
Tags: Dark Green

继承

基类和导出类差异

直接在导出类添加新方法

覆盖

“是一个”和“像是一个”关系

是一个

继承只覆盖基类

纯粹替代

像是一个

在导出类型->新的接口元素

伴随多态的可互换对象
Tags: Dark Gray

特定类型 -> 基类对象

不依赖特定类型的代码

函数调用

前期绑定

非面向对象编程

运行代码的绝对地址

后期绑定

面向对象编程

编译器->确保调用方法的存在

运行时->计算代码的地址

Java编译器

how？

对象中存储信息->计算方法地址

动态绑定是默认的

C++需要virtual关键字

向上转型

导出类->基类

泛型

单根继承结构（Object）
Tags: Red

好处

保证所有对象具有某些功能

极大简化参数传递

容易实现垃圾回收？
Tags: Question

容器
Tags: Orange

List

存储序列

Map

关联数组

Set

集合

Queue、Stack

泛型

向下转型: Object -> 具体类型
Tags: Angry

参数化类型

对象的创建和生命期
Tags: Blue

C++
Tags: Question

追求最大的执行速度

编写时确定：存储空间、生命周期

存储

堆栈

静态存储区

Java

存储

堆的内存池

逻辑假设
Tags: Question

堆内存动态创建对象

垃圾回收机制->内存释放

异常处理：处理错误
Tags: Green

错误->置于编程语言中

Java 内置异常处理，并强制使用

并发编程
Tags: Purple

中断，从而去处理其他问题

隐患：共享资源

Java 与 Internet
Tags: Dark Green

Web 是什么

巨型 客户/服务器 系统

客户端编程

CGI、插件、脚本、Java applet、Java Web Start、Internet|Intranct

服务器端编程

原始数据的发回（负载小）、Servlet JSP、Python、C++、Perl

总结
Tags: Dark Gray

一切都是对象
Tags: Priority 2

用引用操纵对象
Tags: Red

遥控器（引用）->电视机（对象）

安全创建引用，同时进行初始化

必须由你创建所有对象
Tags: Orange

存储到什么地方

寄存器

处理器的寄存器，速度最快

不能直接控制

堆栈

通用RAM中

Java对象引用

堆

通用内存池

Java对象

常量存储（静态、存储区）

程序代码内部

ROM（只读存储器）

非RAM存储（持久化、硬盘）

流对象

持久化对象

特例：基本类型

存“值”于堆栈

高精度数字

BigInteger

BigDecimal

Java 中的数组

自动初始化

范围检查

少量内存开销

运行时的下标检查

永远不需要销毁对象（JVM)
Tags: Blue

作用域

对象的作用域

对象可以存活于作用域之外

创建新的数据类型：类
Tags: Green

字段和方法

对某对象的引用必须初始化

基本成员默认值（不适用于局部变量）

方法、参数和返回值
Tags: Dark Green

参数列表

你的第一个 Java 程序
Tags: Dark Gray

名字可见性

运用其他构件

static 关键字

类数据、类方法

只有一份存储空间，对象共享

首选类名引用（编译器进行优化）

注释和嵌入式文档
Tags: Red

Java doc：提取注释的工具，JDK 的一部分

注释文档

语法

嵌入式 HTML

一些标签示例

文档示例

编码风格

总结

练习

操作符
Tags: Priority 3

更简单的打印语句

使用 Java 操作符

优先级

赋值

必须由一个物理空间存储符号右边的值
Tags: Red

基本类型存储了实际的值，并非对象引用
Tags: Blue

我们真正操作的是对象的引用，将“引用”从一个地方复制到另一个地方
Tags: Green

“别名现象”
Tags: Purple

方法调用中的别名问题

算数操作符

一元加、减操作符

a*-b == a*(-b)

自动递增和递减

++a,a++,--a,a-- 和赋值一样具有“副作用”

关系操作符

测试对象的等价性

equals() 默认比较引用

逻辑操作符

&&，||，！
Tags: Red

短路

不再计算表达式其余部分，潜在性能提升

直接常量

“窄化转型” char/byte/short -> int
Tags: Red

指数记数法

e -> 10的幂次

Integer:toBinaryString()

按位操作符

&  |  ^  ～

二进制“bit”，直接操作硬件

移位操作符

>>、<< 有/无符号截断

三元操作符 if-else

高效但可读性差

字符串操作符 + 和 +=

操作符重载

使用操作符时常犯的错误

不会自动将 int 转换成 boolean

类型转换操作符

截尾和舍入

提升

Java 没有 sizeof

操作符小结

总结

控制执行流程
Tags: Priority 4

true 和false

if-else

迭代

do-while

for

逗号操作符

Foreach 语法

return

break 和 continue

臭名昭著

switch

总结

标签

恰好出现在迭代语句前

continue：继续当前的下一个循环

break：中断当前循环

continue label：继续循环->label处

break label：中断循环->label处

初始化与清理
Tags: Priority 5

用构造器确保初始化

作用

确保每个对象初始化

调用构造器，是编译器的责任

没有返回值

不是返回值为 void

方法重载

区分重载方法

涉及基本类型的重载

以返回值区分重载方法

默认构造器

this 关键字

在构造器中调用构造器

static 的含义

问题

a.peel(1)和b.peel(2)
如何知道调用的是 a 还是 b？

答案

this-所操作对象的引用

作为第一个参数 -> peel()

类似Banana.peel(a, 1)

清理：终结处理和垃圾回收

finalize（）的用途和在

GC前调用finalize（）

GC回收对象内存

你必须实施清理

终结条件

垃圾回收器如何工作

“特殊”内存

GC仅负责new出来的对象

“本地方法”分配的内存，GC无法回收

说明

对象可能不被垃圾回收

垃圾回收只与内存有关

绝对不能直接调用finalize()

成员初始化

指定初始化

构造器初始化

初始化顺序

静态数据的初始化

static{}

首次加载类时执行（即使未生成类对象）

非静态实例初始化

{}

生成对象时执行，匿名内部类的初始化

构造器（最后执行）

数组初始化

可变参数列表

枚举类型

enum类 -> 编译器行为

特性

toString()

ordinal()

特定enum常量的声明顺序

values()

按顺序生成数组

总结

Java 创建对象的过程

检测类是否被加载过

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

为新生对象分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。
假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

进行必要的设置

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

执行init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

创建对象的过程

首次创建Dog对象、访问Dog静态方法，Java解释器定位Dog.class

载入Dog.class，静态初始化

new Dog()时，在对堆上分配空间

存储空间清零

基本类型 -> 默认值

引用 -> null

执行字段定义处的初始化动作

执行构造器

访问权限控制
Tags: Priority 6

包：库单元

代码组织

创建独一无二的包名

制定工具库

用 import 改变行为

对使用包的忠告

Java 访问权限修饰词

包访问权限

public：接口访问权限

private：你无法访问

protected：继承访问权限

接口和实现

类的访问权限

总结

为什么控制访问

复用类
Tags: Priority 7

组合语法

继承语法

初始化基类

代理

结合使用组合和继承

确保正确清理

名称屏蔽

在组合与继承之间选择

protected 关键字

向上转型

为什么称为向上转型

再论组合与继承

final 关键字

final 数据

final 方法

final 类

有关 final 的忠告

初始化及类的加载

继承与初始化

总结

多态
Tags: Priority 8

再论向上转型

忘记对象类型

转机

方法调用绑定

产生正确的行为

可扩展性

缺陷：“覆盖”私有方法

缺陷：域与静态方法

构造器和多态

构造器的调用顺序

继承与清理

构造器内部的多态方法的行为

协变返回类型

用继承进行设计

纯继承与扩展

向下转型与运行时类型识别

总结

接口
Tags: Priority 9

抽象类和抽象方法

接口

完全解耦

Java 中的多重继承

通过继承来扩展接口

组合接口时的名字冲突

适配接口

接口中的域

初始化接口中的域

嵌套接口

接口与工厂

总结

内部类
Tags: January

创建内部类

链接到外部类

使用 .this 与 .new

内部类与向上转型

在方法和作用域内的内部类

匿名内部类

再访工厂方法

嵌套类

接口内部的类

从多层嵌套类中访问外部类的成员

为什么需要内部类

闭包与回调

内部类与控制框架

内部类的继承

内部类可以被覆盖吗

局部内部类

内部类标识符

持有对象
Tags: February

泛型和类型安全的容器

基本概念

添加一组元素

容器的打印

List

迭代器

ListIterator

LinkedList

Stack

Set

Map

Queue

PriorityQueue

Collection 和 Iterator

Foreach 与迭代器

适配器方法惯用法

总结

字符串
Tags: March

类型信息
Tags: April

泛型
Tags: May

数组
Tags: June

容器深入研究
Tags: July
